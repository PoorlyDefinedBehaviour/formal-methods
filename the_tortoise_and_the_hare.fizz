always assertion FindsCycle:
  hasCycle1 = findCycleByKeepingVisitedSet()
  hasCycle2 = tortoiseAndHare()
  return hasCycle1 == hasCycle2

action Init:
  nodes = range(1, 4)

  start = any nodes

  succ = {}
  previous = None

  for node in nodes:
    # The previous node always points to the current node.
    if previous != None:
      succ[previous] = node
      
    # The current node either points to:
    # None
    # Itself
    # Another node that's already in the list
    oneof:
      succ[node] = None
      succ[node] = node
      atomic:
        nodesInThelist = succ.keys()
        next = any nodesInThelist
        succ[node] = next
    
    previous = node

  print("succ", succ)
  

atomic func findCycleByKeepingVisitedSet():
  current = start

  visited = set()

  while current != None:
    if current in visited:
      return True
    visited.add(current)
    current = succ.get(current)

  return False

atomic func tortoiseAndHare():
  tortoise = start
  hare = start

  while True:
    # If the slow pointer has not reached the end of the list. Advance it by 1.
    if tortoise != None:
      tortoise = succ.get(tortoise)

    # Advance the fast pointer by 2.
    for _ in range(0, 2):
      if hare != None:
        hare = succ.get(hare)
          
    if tortoise == None and hare == None:
      return False
      
    if tortoise == hare:
      return True

action NoOp:
    pass